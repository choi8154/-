from abc import ABC, abstractmethod
#디자인 원칙 : 에플리케이션에서 바뀔수 있는 부분과 바뀌지 않는 부분을 찾아 구분하기
#달라지는 부분을 찾아 나머지 부분에 영향을 주지 않도록 캡슐화 하기
#?상속 자체로만 행동을 강제하지 말고, 행동 자체를 따로 빼서 조립하자!



#인스턴스는 파이썬에서 추상클래스로 표현 할 수 있음. abc라이브러리로 표현 가능함.
#추상클래스를 사용하는 이유는 객체를 생성 할 때 객체의 속성 중 변화 가능한 속성을 따로 관리하기 위해서야
#예를들어 전사 클래스로 만든 객체인 A전사라는 인스턴스를 생성했는데 얘가 칼만 쓰다가 활을 좀 써보고싶네?
#만약 전직이라는 슈퍼클래스의 무기라는 메서드를 오버라이딩 해서 "검으로 공격했습니다"를 리턴하게 했어

class 전직:
    무기 = None
    def 공격(self):
        pass

class 전사(전직): 
    무기 = "검" #전사 is-a 무기(상속)
    def 공격(self):
            return f"{self.무기}(으)로 공격했습니다"
A = 전사()
print(A.공격())
B = 전사()
print(B.공격())

#그런데 말했듯 활을 쓰고싶어지잖아 그럼 어떻게 해야함? 당연히 해당 클래스의 속성 바꿔야지.
#그런데;; 다른 전사들의 메서드도 모두 활을 사용하게 됐네!?
#!코드가 변경했을 때 다른 객체들에게 원치않는 영향을 끼칠 수 있음.

class 전사(전직):
    무기 = "활" #A전사(활을 사용하고 싶은 전사): 난 활을 쓰고 싶으니 워리어의 메서드를 수정해야지 ㅎㅎ
    def 공격(self):
            return f"{self.무기}(으)로 공격했습니다" 
A = 전사()
B = 전사()
print(A.공격()) #A전사:헤헷 됐다!
print(B.공격()) #B전사:내 집행검10강이 왜 갑자기 허름한 활로 변경됨? 버그임????

#이런 상황이 나올 수 있다는거지
#그래서 A전사 객체에만 검을 부여하고 싶을 때 동적으로 유연하게 부여가 가능하도록 하는게 추상클래스를 활용한 전략패턴 인거다~~이말이야!
#!목표: 바뀔 수 있는 알고리즘(행동)을 객체 안에서 직접 정의하지 말고, 따로 캡슐화해서 교체 가능하게 만들자.
#자 전략패턴은 그러면 어떻게 사용해야할까?
#전략패턴은 상속으로 행동을 강제하지 않고 동적으로 변경이 가능하도록 변경이 자주 일어나는 메서드를 클래스로 캡슐화해서 따로 관리하는거야
#이걸 코드로 표현하자면 "무슨 무기가 좋음?"라는 추상클래스를 만들고 그 추상클래스를 상속받는 2개의 서브 클래스를 만들어! "활이좋아", "검이좋아"

class 무슨_무기가_좋음(ABC): #추상 클래스
    @abstractmethod
    def 무기를_골라(self):
        pass

class 활이좋아(무슨_무기가_좋음):
    def 무기를_골라(self):
        return "활"
    
class 검이좋아(무슨_무기가_좋음):
    def 무기를_골라(self):
        return "검"
#그리고 우리 전사 클래스에 생성자 메서드에 self.무기 = "무슨 무기가 좋음?"이라는 속성을 만들어!
class 전사:
    def __init__(self, 무기 : 무슨_무기가_좋음):
        self.무기 = 무기 #전사 has-a 무기(구성)

    def 공격(self):
        return f'{self.무기.무기를_골라()}(으)로 공격했습니다.'
#그러면 이제 이 속성에 "활이좋아", "검이좋아" 서브클래스만 넣으면 객체가 원하는 무기를 언제든지 변경이 가능하지!
A = 전사(검이좋아()) 
print(A.공격()) 
B = 전사(검이좋아())
print(B.공격())
#A:검 질리는데 활로 바꿔야지!
A.무기 = 활이좋아()
print(A.공격())
print(B.공격()) #B:저놈은 전사면서 활을쓰네;;

#?내가 긴가민가해서 정리한 것
#self.fly.fly인 이유는 self.fly는 Fly함수의 인스턴스임. 그러므로 self.fly.fly()로 써줘야함.
#?그러면 그냥 perfrom에 인수로 fly를 받으면 self를 귀찮게 할 필요도 없지 않음? 그냥 fly.fly()로 하면 리턴값이 나오잖아?
#그건 우리의 목적은 Bird의 속성이 날 수 있냐 없냐를 구분하는거지 나는 행동 자체를 리턴하는게 아니기 때문이야 멍충아!